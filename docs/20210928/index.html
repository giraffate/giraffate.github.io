<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer-when-downgrade">

    <title>正規表現マッチャをDFAで書く</title>
    <meta name="description" content="三鷹で活動しているクラブチームです">

    <link rel="stylesheet" href="https://mitaka.club/main.css">

    
        <link rel="alternate" type="application/rss+xml" title="RSS" href="https://mitaka.club/index.xml">
    

    
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@giraffate" />
<meta property="og:url" content="https:&#x2F;&#x2F;mitaka.club&#x2F;20210928&#x2F;" />
<meta property="og:title" content="正規表現マッチャをDFAで書く" />
<meta property="og:description" content="" />
<meta property="og:image" content="https:&#x2F;&#x2F;mitaka.club/images/giraffate.jpg" />

</head>
<body>
    <a class="skip-main" href="#main">Skip to content</a>
    <div class="container">
        <header> 
            <h1 class="site-header">
                <a href="https:&#x2F;&#x2F;mitaka.club">Mitaka Club</a>
            </h1>
            <nav>
                
                
                
                <a  href="https:&#x2F;&#x2F;mitaka.club">Home</a>
                
                
                <a  href="https:&#x2F;&#x2F;mitaka.club&#x2F;categories">Categories</a>
                
                
                <a  href="https:&#x2F;&#x2F;mitaka.club&#x2F;tags">Tags</a>
                
                
                <a  href="https:&#x2F;&#x2F;github.com&#x2F;giraffate">GitHub</a>
                
                
                <a  href="https:&#x2F;&#x2F;twitter.com&#x2F;giraffate">Twitter</a>
                
                
            </nav>
        </header>
        <main id="main" tabindex="-1">
            

<article class="post">
    <header>
        <h1>正規表現マッチャをDFAで書く</h1>
    </header>
    <div class="content">
        <p>引き続き <a href="https://swtch.com/~rsc/regexp/regexp1.html">Regular Expression Matching Can Be Simple And Fast</a> を読んでいてようやく読み終わった。</p>
<p>DFA は一度に一つの状態しか保持しないので NFA よりも実行するのに効率的であるとされる。ここで紹介されている Ken Thompson's NFA simulation だと実質的に同等の DFA を実行しているに等しいが、現在保持している状態のリストを捨てているところが非効率なのでその状態のリストをキャッシュとしての DFA に保持しておくという実装が紹介されている。ここで NFA と DFA の対応だが、NFA における状態のリストが DFA における一つの状態に対応していることが以下の図からわかる（以下の図については <a href="https://swtch.com/~rsc/regexp/regexp1.html">Regular Expression Matching Can Be Simple And Fast</a> より引用）。</p>
<p><img src="https://mitaka.club/20210928/../images/20210928/nfa.png" alt="nfa" />
<img src="https://mitaka.club/20210928/../images/20210928/dfa.png" alt="dfa" /></p>
<p>後述するコードに出てくるが <code>Dstate</code> という構造体が DFA の状態に対応する。また、これは必要になったときに作成されキャッシュされ、入力に対する次の状態についても必要になったときに作成されキャッシュされる。</p>
<p><a href="../20210915">前回</a>のコードに DFA の実装を追加した。サポートされている記法は同様で以下の通り。</p>
<table><thead><tr><th>文字</th><th>意味</th></tr></thead><tbody>
<tr><td>c</td><td>文字cそのもの</td></tr>
<tr><td>|</td><td>または</td></tr>
<tr><td>+</td><td>直前の文字の1回以上の反復</td></tr>
<tr><td>*</td><td>直前の文字の0回以上の反復</td></tr>
<tr><td>?</td><td>直前の文字の0 or 1回の表示</td></tr>
</tbody></table>
<pre data-lang="rs" style="background-color:#2b303b;color:#c0c5ce;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="color:#b48ead;">use </span><span>std::cell::{Cell, RefCell};
</span><span style="color:#b48ead;">use </span><span>std::collections::HashMap;
</span><span style="color:#b48ead;">use </span><span>std::rc::Rc;
</span><span style="color:#b48ead;">use </span><span>std::sync::atomic::{AtomicUsize, Ordering};
</span><span style="color:#b48ead;">use </span><span>std::vec;
</span><span>
</span><span style="color:#b48ead;">static </span><span style="color:#d08770;">CNT</span><span>: AtomicUsize = AtomicUsize::new(</span><span style="color:#d08770;">0</span><span>);
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Hello, world!</span><span>&quot;);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">lexer</span><span>(</span><span style="color:#bf616a;">s</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; Vec&lt;</span><span style="color:#b48ead;">char</span><span>&gt; {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> out: Vec&lt;</span><span style="color:#b48ead;">char</span><span>&gt; = Vec::new();
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> s = s.</span><span style="color:#96b5b4;">to_string</span><span>();
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> iter = s.</span><span style="color:#96b5b4;">chars</span><span>().</span><span style="color:#96b5b4;">peekable</span><span>();
</span><span>    </span><span style="color:#b48ead;">while let </span><span>Some(c) = iter.</span><span style="color:#96b5b4;">next</span><span>() {
</span><span>        out.</span><span style="color:#96b5b4;">push</span><span>(c);
</span><span>
</span><span>        </span><span style="color:#b48ead;">if</span><span> c == &#39;</span><span style="color:#a3be8c;">(</span><span>&#39; || c == &#39;</span><span style="color:#a3be8c;">|</span><span>&#39; {
</span><span>            </span><span style="color:#b48ead;">continue</span><span>;
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#b48ead;">if let </span><span>Some(peek) = iter.</span><span style="color:#96b5b4;">peek</span><span>() {
</span><span>            </span><span style="color:#b48ead;">match</span><span> peek {
</span><span>                &#39;</span><span style="color:#a3be8c;">|</span><span>&#39; | &#39;</span><span style="color:#a3be8c;">*</span><span>&#39; | &#39;</span><span style="color:#a3be8c;">+</span><span>&#39; | &#39;</span><span style="color:#a3be8c;">?</span><span>&#39; | &#39;</span><span style="color:#a3be8c;">)</span><span>&#39; =&gt; {}
</span><span>                _ =&gt; out.</span><span style="color:#96b5b4;">push</span><span>(&#39;</span><span style="color:#a3be8c;">.</span><span>&#39;),
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    out
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">re2post</span><span>(</span><span style="color:#bf616a;">re</span><span>: Vec&lt;</span><span style="color:#b48ead;">char</span><span>&gt;) -&gt; Vec&lt;</span><span style="color:#b48ead;">char</span><span>&gt; {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">precedence</span><span>(</span><span style="color:#bf616a;">c</span><span>: </span><span style="color:#b48ead;">char</span><span>) -&gt; </span><span style="color:#b48ead;">usize </span><span>{
</span><span>        </span><span style="color:#b48ead;">match</span><span> c {
</span><span>            &#39;</span><span style="color:#a3be8c;">(</span><span>&#39; | &#39;</span><span style="color:#a3be8c;">)</span><span>&#39; =&gt; </span><span style="color:#d08770;">1</span><span>,
</span><span>            &#39;</span><span style="color:#a3be8c;">|</span><span>&#39; =&gt; </span><span style="color:#d08770;">2</span><span>,
</span><span>            &#39;</span><span style="color:#a3be8c;">.</span><span>&#39; =&gt; </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#65737e;">// concat
</span><span>            &#39;</span><span style="color:#a3be8c;">*</span><span>&#39; | &#39;</span><span style="color:#a3be8c;">+</span><span>&#39; | &#39;</span><span style="color:#a3be8c;">?</span><span>&#39; =&gt; </span><span style="color:#d08770;">4</span><span>,
</span><span>            _ =&gt; </span><span style="color:#d08770;">6</span><span>,
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> out: Vec&lt;</span><span style="color:#b48ead;">char</span><span>&gt; = Vec::new();
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> stack: Vec&lt;</span><span style="color:#b48ead;">char</span><span>&gt; = Vec::new();
</span><span>
</span><span>    </span><span style="color:#b48ead;">for</span><span> c in re.</span><span style="color:#96b5b4;">iter</span><span>() {
</span><span>        </span><span style="color:#b48ead;">match</span><span> c {
</span><span>            &#39;</span><span style="color:#a3be8c;">(</span><span>&#39; =&gt; stack.</span><span style="color:#96b5b4;">push</span><span>(*c),
</span><span>            &#39;</span><span style="color:#a3be8c;">)</span><span>&#39; =&gt; {
</span><span>                </span><span style="color:#b48ead;">while</span><span> stack.</span><span style="color:#96b5b4;">last</span><span>().</span><span style="color:#96b5b4;">is_some</span><span>() &amp;&amp; *stack.</span><span style="color:#96b5b4;">last</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>() != &#39;</span><span style="color:#a3be8c;">(</span><span>&#39; {
</span><span>                    </span><span style="color:#b48ead;">let</span><span> op = stack.</span><span style="color:#96b5b4;">pop</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>                    out.</span><span style="color:#96b5b4;">push</span><span>(op);
</span><span>                }
</span><span>                </span><span style="color:#65737e;">// pop &#39;(&#39;
</span><span>                stack.</span><span style="color:#96b5b4;">pop</span><span>();
</span><span>            }
</span><span>            &#39;</span><span style="color:#a3be8c;">.</span><span>&#39; | &#39;</span><span style="color:#a3be8c;">*</span><span>&#39; | &#39;</span><span style="color:#a3be8c;">+</span><span>&#39; | &#39;</span><span style="color:#a3be8c;">?</span><span>&#39; | &#39;</span><span style="color:#a3be8c;">|</span><span>&#39; =&gt; {
</span><span>                </span><span style="color:#b48ead;">while let </span><span>Some(last) = stack.</span><span style="color:#96b5b4;">last</span><span>() {
</span><span>                    </span><span style="color:#b48ead;">if </span><span style="color:#96b5b4;">precedence</span><span>(*last) &gt;= </span><span style="color:#96b5b4;">precedence</span><span>(*c) {
</span><span>                        </span><span style="color:#b48ead;">let</span><span> op = stack.</span><span style="color:#96b5b4;">pop</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>                        out.</span><span style="color:#96b5b4;">push</span><span>(op);
</span><span>                    } </span><span style="color:#b48ead;">else </span><span>{
</span><span>                        </span><span style="color:#b48ead;">break</span><span>;
</span><span>                    }
</span><span>                }
</span><span>                stack.</span><span style="color:#96b5b4;">push</span><span>(*c);
</span><span>            }
</span><span>            _ =&gt; out.</span><span style="color:#96b5b4;">push</span><span>(*c),
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">while</span><span> stack.</span><span style="color:#96b5b4;">last</span><span>().</span><span style="color:#96b5b4;">is_some</span><span>() {
</span><span>        </span><span style="color:#b48ead;">let</span><span> op = stack.</span><span style="color:#96b5b4;">pop</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>        out.</span><span style="color:#96b5b4;">push</span><span>(op);
</span><span>    }
</span><span>
</span><span>    out
</span><span>}
</span><span>
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span style="color:#b48ead;">struct </span><span>State {
</span><span>    </span><span style="color:#bf616a;">kind</span><span>: StateKind,
</span><span>    </span><span style="color:#bf616a;">out</span><span>: Rc&lt;RefCell&lt;Option&lt;Rc&lt;State&gt;&gt;&gt;&gt;,
</span><span>    </span><span style="color:#bf616a;">out1</span><span>: Rc&lt;RefCell&lt;Option&lt;Rc&lt;State&gt;&gt;&gt;&gt;,
</span><span>    </span><span style="color:#bf616a;">list_id</span><span>: Cell&lt;</span><span style="color:#b48ead;">usize</span><span>&gt;,
</span><span>    </span><span style="color:#bf616a;">id</span><span>: </span><span style="color:#b48ead;">usize</span><span>,
</span><span>}
</span><span>
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span style="color:#b48ead;">enum </span><span>StateKind {
</span><span>    Lit(</span><span style="color:#b48ead;">char</span><span>),
</span><span>    Split,
</span><span>    Match,
</span><span>}
</span><span>
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span style="color:#b48ead;">struct </span><span>Fragment {
</span><span>    </span><span style="color:#bf616a;">start</span><span>: Rc&lt;State&gt;,
</span><span>    </span><span style="color:#bf616a;">outs</span><span>: Vec&lt;Rc&lt;RefCell&lt;Option&lt;Rc&lt;State&gt;&gt;&gt;&gt;&gt;,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">post2nfa</span><span>(</span><span style="color:#bf616a;">post</span><span>: Vec&lt;</span><span style="color:#b48ead;">char</span><span>&gt;) -&gt; Rc&lt;State&gt; {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">patch</span><span>(</span><span style="color:#bf616a;">outs</span><span>: Vec&lt;Rc&lt;RefCell&lt;Option&lt;Rc&lt;State&gt;&gt;&gt;&gt;&gt;, </span><span style="color:#bf616a;">start</span><span>: Rc&lt;State&gt;) {
</span><span>        </span><span style="color:#b48ead;">for</span><span> out in outs {
</span><span>            *out.</span><span style="color:#96b5b4;">borrow_mut</span><span>() = Some(Rc::clone(&amp;start));
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> stack: Vec&lt;Fragment&gt; = Vec::new();
</span><span>
</span><span>    </span><span style="color:#b48ead;">for</span><span> c in post {
</span><span>        </span><span style="color:#b48ead;">match</span><span> c {
</span><span>            &#39;</span><span style="color:#a3be8c;">.</span><span>&#39; =&gt; {
</span><span>                </span><span style="color:#b48ead;">let</span><span> e2 = stack.</span><span style="color:#96b5b4;">pop</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>                </span><span style="color:#b48ead;">let</span><span> e1 = stack.</span><span style="color:#96b5b4;">pop</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>                </span><span style="color:#96b5b4;">patch</span><span>(e1.outs.</span><span style="color:#96b5b4;">clone</span><span>(), Rc::clone(&amp;e2.start));
</span><span>                stack.</span><span style="color:#96b5b4;">push</span><span>(Fragment {
</span><span>                    start: e1.start,
</span><span>                    outs: e2.outs,
</span><span>                })
</span><span>            }
</span><span>            &#39;</span><span style="color:#a3be8c;">|</span><span>&#39; =&gt; {
</span><span>                </span><span style="color:#b48ead;">let</span><span> e2 = stack.</span><span style="color:#96b5b4;">pop</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>                </span><span style="color:#b48ead;">let</span><span> e1 = stack.</span><span style="color:#96b5b4;">pop</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>                </span><span style="color:#b48ead;">let</span><span> s = State {
</span><span>                    kind: StateKind::Split,
</span><span>                    out: Rc::new(RefCell::new(Some(Rc::clone(&amp;e1.start)))),
</span><span>                    out1: Rc::new(RefCell::new(Some(Rc::clone(&amp;e2.start)))),
</span><span>                    list_id: Cell::new(</span><span style="color:#d08770;">0</span><span>),
</span><span>                    id: </span><span style="color:#d08770;">CNT</span><span>.</span><span style="color:#96b5b4;">fetch_add</span><span>(</span><span style="color:#d08770;">1</span><span>, Ordering::SeqCst),
</span><span>                };
</span><span>                stack.</span><span style="color:#96b5b4;">push</span><span>(Fragment {
</span><span>                    start: Rc::new(s),
</span><span>                    outs: e1
</span><span>                        .outs
</span><span>                        .</span><span style="color:#96b5b4;">iter</span><span>()
</span><span>                        .</span><span style="color:#96b5b4;">chain</span><span>(e2.outs.</span><span style="color:#96b5b4;">iter</span><span>())
</span><span>                        .</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">out</span><span>| Rc::clone(out))
</span><span>                        .collect::&lt;Vec&lt;_&gt;&gt;(),
</span><span>                })
</span><span>            }
</span><span>            &#39;</span><span style="color:#a3be8c;">?</span><span>&#39; =&gt; {
</span><span>                </span><span style="color:#b48ead;">let</span><span> e = stack.</span><span style="color:#96b5b4;">pop</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>                </span><span style="color:#b48ead;">let</span><span> s = State {
</span><span>                    kind: StateKind::Split,
</span><span>                    out: Rc::new(RefCell::new(Some(Rc::clone(&amp;e.start)))),
</span><span>                    out1: Rc::new(RefCell::new(None)),
</span><span>                    list_id: Cell::new(</span><span style="color:#d08770;">0</span><span>),
</span><span>                    id: </span><span style="color:#d08770;">CNT</span><span>.</span><span style="color:#96b5b4;">fetch_add</span><span>(</span><span style="color:#d08770;">1</span><span>, Ordering::SeqCst),
</span><span>                };
</span><span>                </span><span style="color:#b48ead;">let</span><span> outs = e
</span><span>                    .outs
</span><span>                    .</span><span style="color:#96b5b4;">iter</span><span>()
</span><span>                    .</span><span style="color:#96b5b4;">chain</span><span>(vec![Rc::clone(&amp;s.out1)].</span><span style="color:#96b5b4;">iter</span><span>())
</span><span>                    .</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">out</span><span>| Rc::clone(out))
</span><span>                    .collect::&lt;Vec&lt;_&gt;&gt;();
</span><span>                stack.</span><span style="color:#96b5b4;">push</span><span>(Fragment {
</span><span>                    start: Rc::new(s),
</span><span>                    outs,
</span><span>                })
</span><span>            }
</span><span>            &#39;</span><span style="color:#a3be8c;">*</span><span>&#39; =&gt; {
</span><span>                </span><span style="color:#b48ead;">let</span><span> e = stack.</span><span style="color:#96b5b4;">pop</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>                </span><span style="color:#b48ead;">let</span><span> s = Rc::new(State {
</span><span>                    kind: StateKind::Split,
</span><span>                    out: Rc::new(RefCell::new(Some(Rc::clone(&amp;e.start)))),
</span><span>                    out1: Rc::new(RefCell::new(None)),
</span><span>                    list_id: Cell::new(</span><span style="color:#d08770;">0</span><span>),
</span><span>                    id: </span><span style="color:#d08770;">CNT</span><span>.</span><span style="color:#96b5b4;">fetch_add</span><span>(</span><span style="color:#d08770;">1</span><span>, Ordering::SeqCst),
</span><span>                });
</span><span>                </span><span style="color:#96b5b4;">patch</span><span>(e.outs, Rc::clone(&amp;s));
</span><span>                </span><span style="color:#b48ead;">let</span><span> out = Rc::clone(&amp;s.out1);
</span><span>                stack.</span><span style="color:#96b5b4;">push</span><span>(Fragment {
</span><span>                    start: s,
</span><span>                    outs: vec![out],
</span><span>                })
</span><span>            }
</span><span>            &#39;</span><span style="color:#a3be8c;">+</span><span>&#39; =&gt; {
</span><span>                </span><span style="color:#b48ead;">let</span><span> e = stack.</span><span style="color:#96b5b4;">pop</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>                </span><span style="color:#b48ead;">let</span><span> s = Rc::new(State {
</span><span>                    kind: StateKind::Split,
</span><span>                    out: Rc::new(RefCell::new(Some(Rc::clone(&amp;e.start)))),
</span><span>                    out1: Rc::new(RefCell::new(None)),
</span><span>                    list_id: Cell::new(</span><span style="color:#d08770;">0</span><span>),
</span><span>                    id: </span><span style="color:#d08770;">CNT</span><span>.</span><span style="color:#96b5b4;">fetch_add</span><span>(</span><span style="color:#d08770;">1</span><span>, Ordering::SeqCst),
</span><span>                });
</span><span>                </span><span style="color:#96b5b4;">patch</span><span>(e.outs, Rc::clone(&amp;s));
</span><span>                </span><span style="color:#b48ead;">let</span><span> out = Rc::clone(&amp;s.out1);
</span><span>                stack.</span><span style="color:#96b5b4;">push</span><span>(Fragment {
</span><span>                    start: e.start,
</span><span>                    outs: vec![out],
</span><span>                })
</span><span>            }
</span><span>            _ =&gt; {
</span><span>                </span><span style="color:#b48ead;">let</span><span> s = State {
</span><span>                    kind: StateKind::Lit(c),
</span><span>                    out: Rc::new(RefCell::new(None)),
</span><span>                    out1: Rc::new(RefCell::new(None)),
</span><span>                    list_id: Cell::new(</span><span style="color:#d08770;">0</span><span>),
</span><span>                    id: </span><span style="color:#d08770;">CNT</span><span>.</span><span style="color:#96b5b4;">fetch_add</span><span>(</span><span style="color:#d08770;">1</span><span>, Ordering::SeqCst),
</span><span>                };
</span><span>
</span><span>                </span><span style="color:#b48ead;">let</span><span> out = Rc::clone(&amp;s.out);
</span><span>                </span><span style="color:#b48ead;">let</span><span> f = Fragment {
</span><span>                    start: Rc::new(s),
</span><span>                    outs: vec![out],
</span><span>                };
</span><span>                stack.</span><span style="color:#96b5b4;">push</span><span>(f);
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> e = stack.</span><span style="color:#96b5b4;">pop</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>    </span><span style="color:#96b5b4;">patch</span><span>(
</span><span>        e.outs,
</span><span>        Rc::new(State {
</span><span>            kind: StateKind::Match,
</span><span>            out: Rc::new(RefCell::new(None)),
</span><span>            out1: Rc::new(RefCell::new(None)),
</span><span>            list_id: Cell::new(</span><span style="color:#d08770;">0</span><span>),
</span><span>            id: </span><span style="color:#d08770;">CNT</span><span>.</span><span style="color:#96b5b4;">fetch_add</span><span>(</span><span style="color:#d08770;">1</span><span>, Ordering::SeqCst),
</span><span>        }),
</span><span>    );
</span><span>    e.start
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">matches</span><span>(</span><span style="color:#bf616a;">start</span><span>: Rc&lt;State&gt;, </span><span style="color:#bf616a;">s</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; </span><span style="color:#b48ead;">bool </span><span>{
</span><span>    </span><span style="color:#b48ead;">let</span><span> chars = s.</span><span style="color:#96b5b4;">to_string</span><span>().</span><span style="color:#96b5b4;">chars</span><span>().collect::&lt;Vec&lt;</span><span style="color:#b48ead;">char</span><span>&gt;&gt;();
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> cnt: </span><span style="color:#b48ead;">usize </span><span>= </span><span style="color:#d08770;">1</span><span>;
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> clist: Vec&lt;Rc&lt;State&gt;&gt; = Vec::new();
</span><span>    </span><span style="color:#96b5b4;">add_state</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> clist, &amp;start, &amp;</span><span style="color:#b48ead;">mut</span><span> cnt);
</span><span>    cnt += </span><span style="color:#d08770;">1</span><span>;
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> nlist: Vec&lt;Rc&lt;State&gt;&gt; = Vec::new();
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> alldstates: HashMap&lt;Vec&lt;</span><span style="color:#b48ead;">usize</span><span>&gt;, Rc&lt;Dstate&gt;&gt; = HashMap::new();
</span><span>    alldstates.</span><span style="color:#96b5b4;">insert</span><span>(
</span><span>        clist.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">state</span><span>| state.id).collect::&lt;Vec&lt;_&gt;&gt;(),
</span><span>        Rc::new(Dstate::new(clist.</span><span style="color:#96b5b4;">clone</span><span>())),
</span><span>    );
</span><span>
</span><span>    </span><span style="color:#b48ead;">for</span><span> c in chars {
</span><span>        </span><span style="color:#65737e;">// ここでclistのキャッシュがあるか調べる。あればキャッシュのnextのlをclistに入れて後続処理をスキップ
</span><span>        </span><span style="color:#65737e;">// State に id を持たせてそれで比較するかな
</span><span>        </span><span style="color:#b48ead;">match</span><span> alldstates.</span><span style="color:#96b5b4;">get</span><span>(&amp;clist.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">state</span><span>| state.id).collect::&lt;Vec&lt;_&gt;&gt;()) {
</span><span>            Some(dstate) </span><span style="color:#b48ead;">if</span><span> dstate.n.</span><span style="color:#96b5b4;">borrow</span><span>().</span><span style="color:#96b5b4;">contains_key</span><span>(&amp;c) =&gt; {
</span><span>                </span><span style="color:#b48ead;">let</span><span> tmp = dstate.n.</span><span style="color:#96b5b4;">borrow</span><span>();
</span><span>                </span><span style="color:#b48ead;">let</span><span> nextstate = tmp.</span><span style="color:#96b5b4;">get</span><span>(&amp;c).</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>                clist = nextstate.l.</span><span style="color:#96b5b4;">clone</span><span>();
</span><span>            }
</span><span>            Some(dstate) =&gt; {
</span><span>                nlist.</span><span style="color:#96b5b4;">clear</span><span>();
</span><span>                </span><span style="color:#96b5b4;">step</span><span>(&amp;clist, &amp;</span><span style="color:#b48ead;">mut</span><span> nlist, c, &amp;</span><span style="color:#b48ead;">mut</span><span> cnt);
</span><span>                dstate
</span><span>                    .n
</span><span>                    .</span><span style="color:#96b5b4;">borrow_mut</span><span>()
</span><span>                    .</span><span style="color:#96b5b4;">insert</span><span>(c, Rc::new(Dstate::new(nlist.</span><span style="color:#96b5b4;">clone</span><span>())));
</span><span>                std::mem::swap(&amp;</span><span style="color:#b48ead;">mut</span><span> clist, &amp;</span><span style="color:#b48ead;">mut</span><span> nlist);
</span><span>            }
</span><span>            None =&gt; {
</span><span>                nlist.</span><span style="color:#96b5b4;">clear</span><span>();
</span><span>                </span><span style="color:#96b5b4;">step</span><span>(&amp;clist, &amp;</span><span style="color:#b48ead;">mut</span><span> nlist, c, &amp;</span><span style="color:#b48ead;">mut</span><span> cnt);
</span><span>                </span><span style="color:#65737e;">// ここでclistを元にDstate作る
</span><span>                </span><span style="color:#b48ead;">let</span><span> d = Dstate::new(clist.</span><span style="color:#96b5b4;">clone</span><span>());
</span><span>                d.n.</span><span style="color:#96b5b4;">borrow_mut</span><span>()
</span><span>                    .</span><span style="color:#96b5b4;">insert</span><span>(c, Rc::new(Dstate::new(nlist.</span><span style="color:#96b5b4;">clone</span><span>())));
</span><span>                </span><span style="color:#65737e;">// 上で作ったDstateをキャッシュする
</span><span>                alldstates.</span><span style="color:#96b5b4;">insert</span><span>(
</span><span>                    clist.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">state</span><span>| state.id).collect::&lt;Vec&lt;_&gt;&gt;(),
</span><span>                    Rc::new(d),
</span><span>                );
</span><span>                std::mem::swap(&amp;</span><span style="color:#b48ead;">mut</span><span> clist, &amp;</span><span style="color:#b48ead;">mut</span><span> nlist);
</span><span>            }
</span><span>        };
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#96b5b4;">is_match</span><span>(&amp;clist)
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">is_match</span><span>(</span><span style="color:#bf616a;">nlist</span><span>: &amp;[Rc&lt;State&gt;]) -&gt; </span><span style="color:#b48ead;">bool </span><span>{
</span><span>    </span><span style="color:#b48ead;">for</span><span> state in nlist {
</span><span>        </span><span style="color:#b48ead;">if let </span><span>StateKind::Match = state.kind {
</span><span>            </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">true</span><span>;
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#d08770;">false
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">step</span><span>(</span><span style="color:#bf616a;">clist</span><span>: &amp;[Rc&lt;State&gt;], </span><span style="color:#bf616a;">nlist</span><span>: &amp;</span><span style="color:#b48ead;">mut </span><span>Vec&lt;Rc&lt;State&gt;&gt;, </span><span style="color:#bf616a;">c</span><span>: </span><span style="color:#b48ead;">char</span><span>, </span><span style="color:#bf616a;">cnt</span><span>: &amp;</span><span style="color:#b48ead;">mut usize</span><span>) {
</span><span>    *cnt += </span><span style="color:#d08770;">1</span><span>;
</span><span>    </span><span style="color:#b48ead;">for</span><span> state in clist {
</span><span>        </span><span style="color:#b48ead;">match</span><span> state.kind {
</span><span>            StateKind::Lit(lit) </span><span style="color:#b48ead;">if</span><span> lit == c =&gt; {
</span><span>                </span><span style="color:#b48ead;">let</span><span> s = Rc::clone(state);
</span><span>                </span><span style="color:#96b5b4;">add_state</span><span>(nlist, s.out.</span><span style="color:#96b5b4;">borrow_mut</span><span>().</span><span style="color:#96b5b4;">as_ref</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>(), cnt);
</span><span>            }
</span><span>            _ =&gt; {}
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">add_state</span><span>(</span><span style="color:#bf616a;">list</span><span>: &amp;</span><span style="color:#b48ead;">mut </span><span>Vec&lt;Rc&lt;State&gt;&gt;, </span><span style="color:#bf616a;">state</span><span>: &amp;Rc&lt;State&gt;, </span><span style="color:#bf616a;">cnt</span><span>: &amp;</span><span style="color:#b48ead;">mut usize</span><span>) {
</span><span>    </span><span style="color:#b48ead;">if</span><span> state.list_id.</span><span style="color:#96b5b4;">get</span><span>() == *cnt {
</span><span>        </span><span style="color:#b48ead;">return</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">if let </span><span>StateKind::Split = state.kind {
</span><span>        </span><span style="color:#96b5b4;">add_state</span><span>(list, state.out.</span><span style="color:#96b5b4;">borrow_mut</span><span>().</span><span style="color:#96b5b4;">as_ref</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>(), cnt);
</span><span>        </span><span style="color:#96b5b4;">add_state</span><span>(list, state.out1.</span><span style="color:#96b5b4;">borrow_mut</span><span>().</span><span style="color:#96b5b4;">as_ref</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>(), cnt);
</span><span>    }
</span><span>
</span><span>    list.</span><span style="color:#96b5b4;">push</span><span>(Rc::clone(state));
</span><span>}
</span><span>
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span style="color:#b48ead;">struct </span><span>Dstate {
</span><span>    </span><span style="color:#bf616a;">l</span><span>: Vec&lt;Rc&lt;State&gt;&gt;,
</span><span>    </span><span style="color:#bf616a;">n</span><span>: RefCell&lt;HashMap&lt;</span><span style="color:#b48ead;">char</span><span>, Rc&lt;Dstate&gt;&gt;&gt;,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>Dstate {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">new</span><span>(</span><span style="color:#bf616a;">s</span><span>: Vec&lt;Rc&lt;State&gt;&gt;) -&gt; Dstate {
</span><span>        Dstate {
</span><span>            l: s,
</span><span>            n: RefCell::new(HashMap::new()),
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">mod </span><span>test {
</span><span>    </span><span style="color:#b48ead;">use super</span><span>::*;
</span><span>
</span><span>    #[</span><span style="color:#bf616a;">test</span><span>]
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">lexer_test</span><span>() {
</span><span>        assert_eq!(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">abc</span><span>&quot;).</span><span style="color:#96b5b4;">iter</span><span>().collect::&lt;String&gt;(), &quot;</span><span style="color:#a3be8c;">a.b.c</span><span>&quot;);
</span><span>        assert_eq!(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">ab|a</span><span>&quot;).</span><span style="color:#96b5b4;">iter</span><span>().collect::&lt;String&gt;(), &quot;</span><span style="color:#a3be8c;">a.b|a</span><span>&quot;);
</span><span>        assert_eq!(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">ab+c</span><span>&quot;).</span><span style="color:#96b5b4;">iter</span><span>().collect::&lt;String&gt;(), &quot;</span><span style="color:#a3be8c;">a.b+.c</span><span>&quot;);
</span><span>        assert_eq!(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">a(bb)+a</span><span>&quot;).</span><span style="color:#96b5b4;">iter</span><span>().collect::&lt;String&gt;(), &quot;</span><span style="color:#a3be8c;">a.(b.b)+.a</span><span>&quot;);
</span><span>    }
</span><span>
</span><span>    #[</span><span style="color:#bf616a;">test</span><span>]
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">re2postfix_test</span><span>() {
</span><span>        assert_eq!(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">abc</span><span>&quot;)).</span><span style="color:#96b5b4;">iter</span><span>().collect::&lt;String&gt;(), &quot;</span><span style="color:#a3be8c;">ab.c.</span><span>&quot;);
</span><span>        assert_eq!(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">ab|a</span><span>&quot;)).</span><span style="color:#96b5b4;">iter</span><span>().collect::&lt;String&gt;(), &quot;</span><span style="color:#a3be8c;">ab.a|</span><span>&quot;);
</span><span>        assert_eq!(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">ab+c</span><span>&quot;)).</span><span style="color:#96b5b4;">iter</span><span>().collect::&lt;String&gt;(), &quot;</span><span style="color:#a3be8c;">ab+.c.</span><span>&quot;);
</span><span>        assert_eq!(
</span><span>            </span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">a(bb)+a</span><span>&quot;)).</span><span style="color:#96b5b4;">iter</span><span>().collect::&lt;String&gt;(),
</span><span>            &quot;</span><span style="color:#a3be8c;">abb.+.a.</span><span>&quot;
</span><span>        );
</span><span>    }
</span><span>
</span><span>    #[</span><span style="color:#bf616a;">test</span><span>]
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">post2nfa_test</span><span>() {
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(vec![&#39;</span><span style="color:#a3be8c;">a</span><span>&#39;]);
</span><span>        assert!(matches!(start.kind, StateKind::Lit(&#39;</span><span style="color:#a3be8c;">a</span><span>&#39;)));
</span><span>        </span><span style="color:#b48ead;">let</span><span> out = Rc::clone(&amp;start.out);
</span><span>        assert!(matches!(
</span><span>            out.</span><span style="color:#96b5b4;">borrow_mut</span><span>().</span><span style="color:#96b5b4;">as_ref</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>().kind,
</span><span>            StateKind::Match
</span><span>        ));
</span><span>
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(vec![&#39;</span><span style="color:#a3be8c;">a</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">b</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">.</span><span>&#39;]);
</span><span>        assert!(matches!(start.kind, StateKind::Lit(&#39;</span><span style="color:#a3be8c;">a</span><span>&#39;)));
</span><span>        </span><span style="color:#b48ead;">let</span><span> out = Rc::clone(&amp;start.out);
</span><span>        assert!(matches!(
</span><span>            out.</span><span style="color:#96b5b4;">borrow_mut</span><span>().</span><span style="color:#96b5b4;">as_ref</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>().kind,
</span><span>            StateKind::Lit(&#39;</span><span style="color:#a3be8c;">b</span><span>&#39;)
</span><span>        ));
</span><span>
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(vec![&#39;</span><span style="color:#a3be8c;">a</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">b</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">|</span><span>&#39;]);
</span><span>        assert!(matches!(start.kind, StateKind::Split));
</span><span>        </span><span style="color:#b48ead;">let</span><span> out = Rc::clone(&amp;start.out);
</span><span>        assert!(matches!(
</span><span>            out.</span><span style="color:#96b5b4;">borrow_mut</span><span>().</span><span style="color:#96b5b4;">as_ref</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>().kind,
</span><span>            StateKind::Lit(&#39;</span><span style="color:#a3be8c;">a</span><span>&#39;)
</span><span>        ));
</span><span>        </span><span style="color:#b48ead;">let</span><span> out1 = Rc::clone(&amp;start.out1);
</span><span>        assert!(matches!(
</span><span>            out1.</span><span style="color:#96b5b4;">borrow_mut</span><span>().</span><span style="color:#96b5b4;">as_ref</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>().kind,
</span><span>            StateKind::Lit(&#39;</span><span style="color:#a3be8c;">b</span><span>&#39;)
</span><span>        ));
</span><span>
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(vec![&#39;</span><span style="color:#a3be8c;">a</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">?</span><span>&#39;]);
</span><span>        assert!(matches!(start.kind, StateKind::Split));
</span><span>        </span><span style="color:#b48ead;">let</span><span> out = Rc::clone(&amp;start.out);
</span><span>        assert!(matches!(
</span><span>            out.</span><span style="color:#96b5b4;">borrow_mut</span><span>().</span><span style="color:#96b5b4;">as_ref</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>().kind,
</span><span>            StateKind::Lit(&#39;</span><span style="color:#a3be8c;">a</span><span>&#39;)
</span><span>        ));
</span><span>        </span><span style="color:#b48ead;">let</span><span> out1 = Rc::clone(&amp;start.out1);
</span><span>        assert!(matches!(
</span><span>            out1.</span><span style="color:#96b5b4;">borrow_mut</span><span>().</span><span style="color:#96b5b4;">as_ref</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>().kind,
</span><span>            StateKind::Match
</span><span>        ));
</span><span>
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(vec![&#39;</span><span style="color:#a3be8c;">a</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">*</span><span>&#39;]);
</span><span>        assert!(matches!(start.kind, StateKind::Split));
</span><span>        </span><span style="color:#b48ead;">let</span><span> out = Rc::clone(&amp;start.out);
</span><span>        assert!(matches!(
</span><span>            out.</span><span style="color:#96b5b4;">borrow_mut</span><span>().</span><span style="color:#96b5b4;">as_ref</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>().kind,
</span><span>            StateKind::Lit(&#39;</span><span style="color:#a3be8c;">a</span><span>&#39;)
</span><span>        ));
</span><span>        assert!(matches!(
</span><span>            out.</span><span style="color:#96b5b4;">borrow_mut</span><span>()
</span><span>                .</span><span style="color:#96b5b4;">as_ref</span><span>()
</span><span>                .</span><span style="color:#96b5b4;">unwrap</span><span>()
</span><span>                .out
</span><span>                .</span><span style="color:#96b5b4;">borrow_mut</span><span>()
</span><span>                .</span><span style="color:#96b5b4;">as_ref</span><span>()
</span><span>                .</span><span style="color:#96b5b4;">unwrap</span><span>()
</span><span>                .kind,
</span><span>            StateKind::Split,
</span><span>        ));
</span><span>        assert!(out
</span><span>            .</span><span style="color:#96b5b4;">borrow_mut</span><span>()
</span><span>            .</span><span style="color:#96b5b4;">as_ref</span><span>()
</span><span>            .</span><span style="color:#96b5b4;">unwrap</span><span>()
</span><span>            .out1
</span><span>            .</span><span style="color:#96b5b4;">borrow_mut</span><span>()
</span><span>            .</span><span style="color:#96b5b4;">is_none</span><span>(),);
</span><span>        </span><span style="color:#b48ead;">let</span><span> out1 = Rc::clone(&amp;start.out1);
</span><span>        assert!(matches!(
</span><span>            out1.</span><span style="color:#96b5b4;">borrow_mut</span><span>().</span><span style="color:#96b5b4;">as_ref</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>().kind,
</span><span>            StateKind::Match
</span><span>        ));
</span><span>
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(vec![&#39;</span><span style="color:#a3be8c;">a</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">+</span><span>&#39;]);
</span><span>        assert!(matches!(start.kind, StateKind::Lit(&#39;</span><span style="color:#a3be8c;">a</span><span>&#39;)));
</span><span>        </span><span style="color:#b48ead;">let</span><span> out = Rc::clone(&amp;start.out);
</span><span>        assert!(matches!(
</span><span>            out.</span><span style="color:#96b5b4;">borrow_mut</span><span>().</span><span style="color:#96b5b4;">as_ref</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>().kind,
</span><span>            StateKind::Split,
</span><span>        ));
</span><span>        assert!(matches!(
</span><span>            out.</span><span style="color:#96b5b4;">borrow_mut</span><span>()
</span><span>                .</span><span style="color:#96b5b4;">as_ref</span><span>()
</span><span>                .</span><span style="color:#96b5b4;">unwrap</span><span>()
</span><span>                .out
</span><span>                .</span><span style="color:#96b5b4;">borrow_mut</span><span>()
</span><span>                .</span><span style="color:#96b5b4;">as_ref</span><span>()
</span><span>                .</span><span style="color:#96b5b4;">unwrap</span><span>()
</span><span>                .kind,
</span><span>            StateKind::Lit(&#39;</span><span style="color:#a3be8c;">a</span><span>&#39;),
</span><span>        ));
</span><span>    }
</span><span>
</span><span>    #[</span><span style="color:#bf616a;">test</span><span>]
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">matches_test</span><span>() {
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">a</span><span>&quot;)));
</span><span>        assert!(</span><span style="color:#96b5b4;">matches</span><span>(start, &quot;</span><span style="color:#a3be8c;">a</span><span>&quot;));
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">a</span><span>&quot;)));
</span><span>        assert!(!</span><span style="color:#96b5b4;">matches</span><span>(start, &quot;</span><span style="color:#a3be8c;">ab</span><span>&quot;));
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">a</span><span>&quot;)));
</span><span>        assert!(!</span><span style="color:#96b5b4;">matches</span><span>(start, &quot;</span><span style="color:#a3be8c;">b</span><span>&quot;));
</span><span>
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">ab</span><span>&quot;)));
</span><span>        assert!(</span><span style="color:#96b5b4;">matches</span><span>(start, &quot;</span><span style="color:#a3be8c;">ab</span><span>&quot;));
</span><span>
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">a|b</span><span>&quot;)));
</span><span>        assert!(</span><span style="color:#96b5b4;">matches</span><span>(start, &quot;</span><span style="color:#a3be8c;">a</span><span>&quot;));
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">a|b</span><span>&quot;)));
</span><span>        assert!(</span><span style="color:#96b5b4;">matches</span><span>(start, &quot;</span><span style="color:#a3be8c;">b</span><span>&quot;));
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">a|b</span><span>&quot;)));
</span><span>        assert!(!</span><span style="color:#96b5b4;">matches</span><span>(start, &quot;</span><span style="color:#a3be8c;">c</span><span>&quot;));
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">abcd|bc?da</span><span>&quot;)));
</span><span>        assert!(</span><span style="color:#96b5b4;">matches</span><span>(start, &quot;</span><span style="color:#a3be8c;">abcd</span><span>&quot;));
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">abcd|bc?da</span><span>&quot;)));
</span><span>        assert!(</span><span style="color:#96b5b4;">matches</span><span>(start, &quot;</span><span style="color:#a3be8c;">bcda</span><span>&quot;));
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">abcd|bc?da</span><span>&quot;)));
</span><span>        assert!(</span><span style="color:#96b5b4;">matches</span><span>(start, &quot;</span><span style="color:#a3be8c;">bda</span><span>&quot;));
</span><span>
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">a?</span><span>&quot;)));
</span><span>        assert!(</span><span style="color:#96b5b4;">matches</span><span>(start, &quot;&quot;));
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">a?</span><span>&quot;)));
</span><span>        assert!(</span><span style="color:#96b5b4;">matches</span><span>(start, &quot;</span><span style="color:#a3be8c;">a</span><span>&quot;));
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">a?a</span><span>&quot;)));
</span><span>        assert!(</span><span style="color:#96b5b4;">matches</span><span>(start, &quot;</span><span style="color:#a3be8c;">a</span><span>&quot;));
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">a?a</span><span>&quot;)));
</span><span>        assert!(</span><span style="color:#96b5b4;">matches</span><span>(start, &quot;</span><span style="color:#a3be8c;">aa</span><span>&quot;));
</span><span>
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">a*</span><span>&quot;)));
</span><span>        assert!(</span><span style="color:#96b5b4;">matches</span><span>(start, &quot;&quot;));
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">a*</span><span>&quot;)));
</span><span>        assert!(</span><span style="color:#96b5b4;">matches</span><span>(start, &quot;</span><span style="color:#a3be8c;">a</span><span>&quot;));
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">a*</span><span>&quot;)));
</span><span>        assert!(</span><span style="color:#96b5b4;">matches</span><span>(start, &quot;</span><span style="color:#a3be8c;">aaaaaaaa</span><span>&quot;));
</span><span>
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">a+</span><span>&quot;)));
</span><span>        assert!(!</span><span style="color:#96b5b4;">matches</span><span>(start, &quot;&quot;));
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">a+</span><span>&quot;)));
</span><span>        assert!(</span><span style="color:#96b5b4;">matches</span><span>(start, &quot;</span><span style="color:#a3be8c;">a</span><span>&quot;));
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">a+</span><span>&quot;)));
</span><span>        assert!(</span><span style="color:#96b5b4;">matches</span><span>(start, &quot;</span><span style="color:#a3be8c;">aaaaaaaa</span><span>&quot;));
</span><span>
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">a?a?a?aaa</span><span>&quot;)));
</span><span>        assert!(</span><span style="color:#96b5b4;">matches</span><span>(start, &quot;</span><span style="color:#a3be8c;">aaa</span><span>&quot;));
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = </span><span style="color:#96b5b4;">post2nfa</span><span>(</span><span style="color:#96b5b4;">re2post</span><span>(</span><span style="color:#96b5b4;">lexer</span><span>(&quot;</span><span style="color:#a3be8c;">a?a?a?aaa</span><span>&quot;)));
</span><span>        assert!(</span><span style="color:#96b5b4;">matches</span><span>(start, &quot;</span><span style="color:#a3be8c;">aaaaaa</span><span>&quot;));
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="can-kao">参考</h2>
<ul>
<li><a href="https://swtch.com/~rsc/regexp/regexp1.html">Regular Expression Matching Can Be Simple And Fast</a></li>
</ul>

    </div>

    
    <div class="article-info">
        
        <div class="article-date">28 September 2021</div>
        
        <div class="article-taxonomies">
            
                <ul class="article-categories">
                    
                    <li><a href="https://mitaka.club/categories/programming/">programming</a></li>
                    
                </ul>
            
            
                <ul class="article-tags">
                    
                    <li><a href="https://mitaka.club/tags/rust/">#rust</a></li>
                    
                </ul>
            
        </div>
    </div>

</article>


        </main>
        <footer>
            <p>
                © Mitaka Club 2022<br>
                Powered by <a target="_blank" href="https://getzola.com/">Zola</a>, Theme <a target="_blank" href="https://github.com/zbrox/anpu-zola-theme">Anpu</a>.
            </p>
            <p>
                
                
            </p>
        </footer>
    </div>
</body>
</html>
